---
layout: post
title:  "Понимаем FFmpeg"
date:   2016-03-19 11:34:00 +0300
permalink: /understanding-ffmpeg/
tags: [ffmpeg, video, audio]
keywords: [ffmpeg, video, audio]
author: arsich
---
FFmpeg&nbsp;&mdash; это набор библиотек для обработки видео и&nbsp;аудио файлов. FFmpeg сконвертирует mov в&nbsp;mp4, наложит водяной знак, склеит несколько видео файлов в&nbsp;один, поменяет разрешение, перекодирует потоковое видео, создаст поток сам. FFmpeg полезен для тех, кто профессионально работает с&nbsp;видео, разрабатывает медиа приложения или просто обрабатывает домашние записи.

FFmpeg не&nbsp;имеет графического интерфейса и&nbsp;управляется командами из&nbsp;консоли. Многие пользователи работают с&nbsp;ним, копируя нужные команды из&nbsp;интернета, не&nbsp;понимая, что значит тот или иной флаг. Научимся осознанно работать с&nbsp;FFmpeg на&nbsp;примере нескольких полезных команд.

<!--more-->

Сегодня мы&nbsp;пройдем путь от&nbsp;получения информации о&nbsp;файле до&nbsp;применения нескольких фильтров одновременно, решая задачи, с&nbsp;которыми часто сталкиваешься при работе с&nbsp;видео. Установим ffmpeg и&nbsp;вперед!

### Получаем информацию о файле ###

```
ffmpeg -i file.mp4
```

Тут все просто, вводим путь к&nbsp;файлу, получаем информацию о&nbsp;нем: кодеки, количество дорожек, разрешение, битрейт и&nbsp;фреймрейт. Можно ввести сразу несколько: ```-i file1.mp4 -i file2.mp4```.

### Конвертируем в mp4 ###
Допустим у&nbsp;нас есть сайт, на&nbsp;котором видео проигрывалось через Flash плеер. Мы&nbsp;хотим поменять его на&nbsp;HTML5&nbsp;Video. Для этого конвертируем видео файлы на&nbsp;сервере из&nbsp;flv формата в&nbsp;mp4.

```
ffmpeg -i flashvideo.flv -vcodec libx264 -acodec libvo_aacenc output.mp4
```

По&nbsp;сравнению с&nbsp;предыдущей командой добавилось три поля. ```output.mp4``` &mdash; путь к&nbsp;сконвертированному файлу. ```-vcodec libx264``` &mdash; указываем какой видео кодек хотим получить. В&nbsp;нашем случае это H264, который поддерживается [большинством браузеров](http://caniuse.com/#feat=mpeg4). Аналогично указываем аудио кодек [AAC](http://caniuse.com/#feat=aac).

Список поддерживаемых вашим ffmpeg кодеков можно получить через ```ffmpeg -codecs```, форматов — ```ffmpeg -formats```.

Вместо ```-vcodec``` встречается запись ```-codec:v``` и ```-c:v```. Если не&nbsp;указать кодеки для конвертации ```ffmpeg -i flashvideo.flv output.mp4```, то&nbsp;ffmpeg [установит дефолтные кодеки для формата файла на выходе](http://stackoverflow.com/a/17793689).

При конвертации меняют не&nbsp;только кодеки. Увеличим число настроек:


```
ffmpeg -i flashvideo.flv -b:v 700k -r 25 -pix_fmt yuv420p -vcodec libx264 -b:a 128k -ar 44100 -acodec libvo_aacenc -y output.mp4
```

Мы&nbsp;установили битрейт для видео ```-b:v``` и&nbsp;аудио ```-b:a``` в&nbsp;700 и&nbsp;128&nbsp;кб/c. Битрейт можно обозначить другими флагами: ```-vb``` и ```-b``` для видео или ```-ab``` для аудио.

Оставшиеся три параметра&nbsp;&mdash; это фреймрейт ```-r 25``` в&nbsp;кадрах в&nbsp;секунду, [цветовая модель YUV](http://www.fourcc.org/yuv.php) равная обычному значению yuv420p и&nbsp;[частота дискретизации звука](http://wikisound.org/Частота_дискретизации) 44100 Гц. Флаг ```-y``` нужен для перезаписи файла, если он&nbsp;уже существует.

### Вырезаем фрагмент видео ###

```
ffmpeg -i source_video.mp4 -ss 10 -t 20 -vcodec copy -acodec copy result.mp4
```

Флагом ```-ss``` указываем с&nbsp;какого момента исходного видео обрезаем, ```-t``` &mdash; продолжительность. На&nbsp;выходе мы&nbsp;получим двадцати секундное видео, которое начнется на&nbsp;десятой секунды исходного. Запись ```-ss 00:00:10.250 -t 00:00:20.120``` пригодится для указания более точного промежутка времени. Стоит учесть, что в&nbsp;обоих случаях ffmpeg обрежет видео по&nbsp;ближайшему к&nbsp;указанному времени [ключевому кадру](https://en.wikipedia.org/wiki/Key_frame).

Мы&nbsp;добавили ```-vcodec copy -acodec copy``` чтобы сохранить кодеки исходного видео. Иначе ffmpeg перекодировал&nbsp;бы их&nbsp;в&nbsp;кодеки по&nbsp;умолчанию.

### Фильтры. Меняем разрешение ###

Один из&nbsp;самых мощных инструментов ffmpeg&nbsp;&mdash; фильтры. Они могут добавлять эффекты, накладывать разные видео друг на&nbsp;друга, сшивать несколько файлов в&nbsp;один. Увидеть список установленных фильтров мы&nbsp;можем по&nbsp;команде ```ffmpeg -filters```. Изменим с&nbsp;их&nbsp;помощью разрешение видео:

```
ffmpeg -i source_video.avi -vf scale=640:480 source_preview.avi
```

Мы использовали флаг ```-vf```, указав  фильтр ```scale``` и&nbsp;разрешение ```640:480```. Этот фильтр может
<a href="https://trac.ffmpeg.org/wiki/Scaling%20(resizing)%20with%20ffmpeg)">сохранять пропорции и&nbsp;вычислять разрешение динамически</a>.

### Объединение фильтров. Ускоряем воспроизведение ###

```
ffmpeg -i source_video.mp4 -filter_complex "[0:v]setpts=0.5*PTS;[0:a]atempo=2.0" accelerated.mp4
```

Мы&nbsp;объединили несколько фильтров в&nbsp;один флагом ```filter_complex``` и&nbsp;получили ускоренный в&nbsp;два раза файл. Чтобы разобраться применим фильтры по&nbsp;одиночке.

```
ffmpeg -i source_video.mp4 -vf setpts=0.5*PTS accelerated_video.mp4
```

Мы&nbsp;ускорили воспроизведение видео дорожки фильтром ```setpts```. Однако аудиодорожка не&nbsp;изменилась, и&nbsp;файл получится той&nbsp;же продолжительности что и&nbsp;был: видео проиграется в&nbsp;2&nbsp;раза быстрее, а&nbsp;последний кадр будет висеть всю вторую половину файла. Если аудио дорожка не&nbsp;нужна, уберем ее&nbsp;флагом ```-an```, тогда длительность итогового файла будет определяться по&nbsp;видео дорожке и&nbsp;будет в&nbsp;два раза меньше исходной.

Наоборот, если нужна только ускоренная аудио дорожка без видео, воспользуемся фильтром ```atempo``` и&nbsp;флагом ```vn```.

```
ffmpeg -i source_video.mp4 -af atempo=2.0 -vn accelerated_audio.mp3
```

Добавив ```filter_complex``` и&nbsp;применив оба фильтра, мы&nbsp;ускорили файл целиком.

[Граф фильтров](http://ffmpeg.org/ffmpeg-filters.html#Filtergraph-description) применяет последовательность из&nbsp;нескольких фильтров к&nbsp;исходному файлу. Мы&nbsp;указали ускорение ```setpts``` для видео дорожки ```[0:v]``` и ```atempo``` для аудио ```[0:a]```. С&nbsp;помощью комбинаций фильтров мы&nbsp;можем решить большинство задач по&nbsp;редактированию видео.

### Склеиваем файлы в один ###

```
ffmpeg -i input1.mp4 -i input2.mp4  -filter_complex  "[0:0] [0:1] [1:0] [1:1] concat=n=2:v=1:a=1 [v] [a]" -map "[v]" -map "[a]" -y output.mp4
```

Мы&nbsp;видим новый флаг ```map```. Он&nbsp;указывает ffmpeg какие дорожки хотим получить в&nbsp;итоговом файле. Если в&nbsp;наших исходных видео файлах гарантировано одна видео и&nbsp;аудио дорожка, и&nbsp;столько&nbsp;же мы&nbsp;хотим получить на&nbsp;выходе, то&nbsp;флаг map не&nbsp;нужен. Другие примеры использования Map можно посмотреть&nbsp;на [сайте ffmpeg](https://trac.ffmpeg.org/wiki/Map).

Выполним ту же операцию другим методом:

```
ffmpeg -f concat -i list.txt -c copy output.mp4
```

Содержимое list.txt:

```
file 'input1.mp4'
file 'input2.mp4'
```

Такой метод удобен, если у&nbsp;нас много файлов и&nbsp;надо склеить их&nbsp;друг за&nbsp;другом. Первый метод дает большую гибкость, например если нужна только часть первого видео, мы&nbsp;можем воспользоваться флагами ```-ss``` и ```-t```. Обратите внимание, эти флаги действуют только на&nbsp;первый файл ```input1.mp4```.

```
ffmpeg -ss 5 -t 2 -i input1.mp4  -i input2.mp4  -filter_complex  "[0:0] [0:1] [1:0] [1:1] concat=n=2:v=1:a=1 [v] [a]" -map "[v]" -map "[a]"  -y result.mp4
```

### Водяной знак ###

Последний пример, который мы&nbsp;рассмотрим&nbsp;&mdash; это наложение водяного знака. Фильтр ```overlay``` принимает на&nbsp;вход координаты расположения водяного знака на&nbsp;итоговом видео.

Расположим водяной знак по&nbsp;центру. Зная размер исходного видео и&nbsp;png картинки, можно вычислить координаты самим. Например при видео 1280&times;720 и&nbsp;водяном знаке 200&times;200, положение по&nbsp;горизонтали ```x = (1280 - 200) / 2 = 540``` и&nbsp;по&nbsp;вертикали ```y = (720 - 200) / 2 = 260```. Соответственно значение фильтра ```"overlay=540:260"```. Однако удобнее написать универсальную команду, чтобы ffmpeg посчитал все за&nbsp;нас. Размер видео получим из&nbsp;параметров ```main_w``` и&nbsp;```main_h```, а&nbsp;водяного знака из&nbsp;```overlay_w``` и&nbsp;```overlay_h```. Далее ту формулу, по которой мы вычисляли координаты запишем в значение фильтра ```"overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2"```. Готово, мы&nbsp;получили команду для наложения водяного знака по центру:

```
ffmpeg -i source_video.mp4 -i watermark.png -filter_complex "overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2" -codec:a copy video_protected.mp4
```

FFmpeg&nbsp;&mdash; мощный инструмент для работы с&nbsp;видео. Решение других задач с&nbsp;его помощью можно посмотреть в&nbsp;статье [19 команд ffmpeg для всех нужд](http://www.catswhocode.com/blog/19-ffmpeg-commands-for-all-needs).
