---
layout: post
title:  "Понимаем FFmpeg"
date:   2016-03-19 11:34:00 +0300
permalink: /understanding-ffmpeg/
tags: [ffmpeg, video, audio]
keywords: [ffmpeg, video, audio]
author: arsich
---
FFmpeg — это набор библиотек для обработки видео и аудио файлов. FFmpeg сконвертирует mov в mp4, наложит водяной знак, склеит несколько видео файлов в один, поменяет разрешение, перекодирует потоковое видео, создаст поток сам. FFmpeg полезен для тех, кто профессионально работает с видео, разрабатывает медиа приложения или просто обрабатывает домашние записи.

FFmpeg не имеет графического интерфейса и управляется командами из консоли. Многие пользователи работают с ним, копируя нужные команды из интернета, не понимая, что значит тот или иной флаг. Научимся осознанно работать с FFmpeg на примере нескольких полезных команд.

<!--more-->

Сегодня мы пройдем путь от получения информации о файле до применения нескольких фильтров одновременно, решая задачи, с которыми часто сталкиваешься при работе с видео. Установим ffmpeg и вперед!

### Получаем информацию о файле ###

```
ffmpeg -i file.mp4
```

Тут все просто, вводим путь к файлу, получаем информацию о нем: кодеки, количество дорожек, разрешение, битрейт и фреймрейт. Можно ввести сразу несколько: ```-i file1.mp4 -i file2.mp4```.

### Конвертируем в mp4 ###
Допустим у нас есть сайт, на котором видео проигрывалось через Flash плеер. Мы хотим поменять его на HTML5 Video. Для этого конвертируем видео файлы на сервере из flv формата в mp4.

```
ffmpeg -i flashvideo.flv -vcodec libx264 -acodec libvo_aacenc output.mp4
```

По сравнению с предыдущей командой добавилось три поля. ```output.mp4``` — путь к сконвертированному файлу.  ```-vcodec libx264``` — указываем какой видео кодек хотим получить. В нашем случае это H264, который поддерживается [большинством браузеров](http://caniuse.com/#feat=mpeg4). Аналогично указываем аудио кодек [AAC](http://caniuse.com/#feat=aac).

Список поддерживаемых вашим ffmpeg кодеков можно получить через ```ffmpeg -codecs```, форматов — ```ffmpeg -formats```.

Вместо ```-vcodec``` встречается запись ```-codec:v``` и ```-c:v```. Если не указать кодеки для конвертации ```ffmpeg -i flashvideo.flv output.mp4```, то ffmpeg [установит дефолтные кодеки для формата файла на выходе](http://stackoverflow.com/a/17793689).

При конвертации меняют не только кодеки. Увеличим число настроек:


```
ffmpeg -i flashvideo.flv -b:v 700k -r 25 -pix_fmt yuv420p -vcodec libx264 -b:a 128k -ar 44100 -acodec libvo_aacenc -y output.mp4
```

Мы установили битрейт для видео ```-b:v``` и аудио ```-b:a``` в 700 и 128 кб/c. Битрейт можно обозначить другими флагами: ```-vb``` и ```-b``` для видео или ```-ab``` для аудио.

Оставшиеся три параметра — это фреймрейт ```-r 25``` в кадрах в секунду, [цветовая модель YUV](http://www.fourcc.org/yuv.php) равная обычному значению yuv420p и [частота дискретизации звука](http://wikisound.org/Частота_дискретизации) 44100 Гц. Флаг ```-y``` нужен для перезаписи файла, если он уже существует.

### Вырезаем фрагмент видео ###

```
ffmpeg -i source_video.mp4 -ss 10 -t 20 -vcodec copy -acodec copy result.mp4
```

Флагом ```-ss``` указываем с какого момента исходного видео обрезаем, ```-t``` — продолжительность. На выходе мы получим двадцати секундное видео, которое начнется на десятой секунды исходного. Запись ```-ss 00:00:10.250 -t 00:00:20.120``` пригодится для указания более точного промежутка времени. Стоит учесть, что в обоих случаях ffmpeg обрежет видео по ближайшему к указанному времени [ключевому кадру](https://en.wikipedia.org/wiki/Key_frame).

Мы добавили ```-vcodec copy -acodec copy``` чтобы сохранить кодеки исходного видео. Иначе ffmpeg перекодировал бы их в кодеки по умолчанию.

### Фильтры. Меняем разрешение ###

Один из самых мощных инструментов ffmpeg — фильтры. Они могут добавлять эффекты, накладывать разные видео друг на друга, сшивать несколько файлов в один. Увидеть список установленных фильтров мы можем по команде ```ffmpeg -filters```. Изменим с их помощью разрешение видео:

```
ffmpeg -i source_video.avi -vf scale=640:480 source_preview.avi
```

Мы использовали флаг ```-vf```, указав  фильтр ```scale``` и разрешение ```640:480```. Этот фильтр может
<a href="https://trac.ffmpeg.org/wiki/Scaling%20(resizing)%20with%20ffmpeg)">сохранять пропорции и вычислять разрешение динамически</a>.

### Объединение фильтров. Ускоряем воспроизведение ###

```
ffmpeg -i source_video.mp4 -filter_complex "[0:v]setpts=0.5*PTS;[0:a]atempo=2.0" accelerated.mp4
```

Мы объединили несколько фильтров в один флагом ```filter_complex``` и получили ускоренный в два раза файл. Чтобы разобраться применим фильтры по одиночке.

```
ffmpeg -i source_video.mp4 -vf setpts=0.5*PTS accelerated_video.mp4
```

Мы ускорили воспроизведение видео дорожки фильтром ```setpts```. Однако аудиодорожка не изменилась, и файл получится той же продолжительности что и был: видео проиграется в 2 раза быстрее, а последний кадр будет висеть всю вторую половину файла. Если аудио дорожка не нужна, уберем ее флагом ```-an```, тогда длительность итогового файла будет определяться по видео дорожке и будет в два раза меньше исходной.

Наоборот, если нужна только ускоренная аудио дорожка без видео, воспользуемся фильтром ```atempo``` и флагом ```vn```.

```
ffmpeg -i source_video.mp4 -af atempo=2.0 -vn accelerated_audio.mp3
```

Добавив ```filter_complex``` и применив оба фильтра, мы ускорили файл целиком.

[Граф фильтров](http://ffmpeg.org/ffmpeg-filters.html#Filtergraph-description) применяет последовательность из нескольких фильтров к исходному файлу. Мы указали ускорение ```setpts``` для видео дорожки ```[0:v]``` и ```atempo``` для аудио ```[0:a]```. С помощью комбинаций фильтров мы можем решить большинство задач по редактированию видео.

### Склеиваем файлы в один ###

```
ffmpeg -i input1.mp4 -i input2.mp4  -filter_complex  "[0:0] [0:1] [1:0] [1:1] concat=n=2:v=1:a=1 [v] [a]" -map "[v]" -map "[a]" -y output.mp4
```

Мы видим новый флаг ```map```. Он указывает ffmpeg какие дорожки хотим получить в итоговом файле. Если в наших исходных видео файлах гарантировано одна видео и аудио дорожка, и столько же мы хотим получить на выходе, то флаг map не нужен. Другие примеры использования Map можно посмотреть на [сайте ffmpeg](https://trac.ffmpeg.org/wiki/Map).

Выполним ту же операцию другим методом:

```
ffmpeg -f concat -i list.txt -c copy output.mp4
```

Содержимое list.txt:

```
file 'input1.mp4'
file 'input2.mp4'
```

Такой метод удобен, если у нас много файлов и надо склеить их друг за другом. Первый метод дает большую гибкость, например если нужна только часть первого видео, мы можем воспользоваться флагами ```-ss``` и ```-t```. Обратите внимание, эти флаги действуют только на первый файл ```input1.mp4```.

```
ffmpeg -ss 5 -t 2 -i input1.mp4  -i input2.mp4  -filter_complex  "[0:0] [0:1] [1:0] [1:1] concat=n=2:v=1:a=1 [v] [a]" -map "[v]" -map "[a]"  -y result.mp4
```

### Водяной знак ###

Последний пример, который мы рассмотрим — это наложение водяного знака. Фильтр ```overlay``` принимает на вход координаты расположения водяного знака на итоговом видео.

Расположим водяной знак по центру. Зная размер исходного видео и png картинки, можно вычислить координаты самим. Например при видео 1280x720 и водяном знаке 200x200, положение по горизонтали ```x = (1280 - 200) / 2 = 540``` и по вертикали ```y = (720 - 200) / 2 = 260```. Соответственно значение фильтра ```"overlay=540:260"```. Однако удобнее написать универсальную команду, чтобы ffmpeg посчитал все за нас. Размер видео получим из параметров ```main_w``` и ```main_h```, а водяного знака из ```overlay_w``` и ```overlay_h```. Далее ту формулу, по которой мы вычисляли координаты запишем в значение фильтра ```"overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2"```. Готово, мы получили команду для наложения водяного знака по центру:

```
ffmpeg -i source_video.mp4 -i watermark.png -filter_complex "overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2" -codec:a copy video_protected.mp4
```

FFmpeg — мощный инструмент для работы с видео. Решение других задач с его помощью можно посмотреть в статье [19 команд ffmpeg для всех нужд](http://www.catswhocode.com/blog/19-ffmpeg-commands-for-all-needs).
