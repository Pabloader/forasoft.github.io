---
layout: post
title:  "Понимаем FFmpeg"
date:   2016-03-20 21:00:00 +0300
permalink: /understanding-ffmpeg/
tags: [ffmpeg, video, audio]
keywords: [ffmpeg, video, audio]
author: arsich
---
FFmpeg&nbsp;&mdash; это набор библиотек для обработки видео и&nbsp;аудио файлов. FFmpeg сконвертирует mov в&nbsp;mp4, наложит водяной знак, склеит несколько видео файлов в&nbsp;один, поменяет разрешение, перекодирует потоковое видео, создаст поток сам. FFmpeg полезен для тех, кто профессионально работает с&nbsp;видео, разрабатывает медиа приложения или просто обрабатывает домашние записи.

FFmpeg не&nbsp;имеет графического интерфейса и&nbsp;управляется командами из&nbsp;консоли. Многие пользователи работают с&nbsp;ним, копируя нужные команды из&nbsp;интернета, не&nbsp;понимая, что значит тот или иной флаг. Научимся осознанно работать с&nbsp;FFmpeg на&nbsp;примере нескольких полезных команд.

<!--more-->

Сегодня мы&nbsp;пройдем путь от&nbsp;получения информации о&nbsp;файле до&nbsp;применения нескольких фильтров одновременно, решая задачи, с&nbsp;которыми часто сталкиваешься при работе с&nbsp;видео. Установим ffmpeg и&nbsp;вперед!

## Получаем информацию о файле ##

<pre><code>ffmpeg -i file.mp4</code></pre>

Тут все просто, вводим путь к&nbsp;файлу, получаем информацию о&nbsp;нем: кодеки, количество дорожек, разрешение, битрейт и&nbsp;фреймрейт. Мы&nbsp;указываем пути к&nbsp;файлам флагом ```-i``` (input):

```-i file1.mp4 -i file2.mp4```.

## Конвертируем в mp4 ##
Допустим у&nbsp;нас есть сайт, на&nbsp;котором видео проигрывалось через Flash плеер. Мы&nbsp;хотим поменять его на&nbsp;HTML5&nbsp;Video. Для этого конвертируем видео файлы на&nbsp;сервере из&nbsp;flv формата в&nbsp;mp4.

<pre><code>ffmpeg -i flashvideo.flv <b>-vcodec libx264 -acodec libvo_aacenc output.mp4</b>
</code></pre>

По&nbsp;сравнению с&nbsp;предыдущей командой добавилось три поля.

* ```output.mp4``` &mdash; путь к&nbsp;сконвертированному файлу.
* ```-vcodec libx264``` &mdash; указываем какой видео кодек хотим получить. В&nbsp;нашем случае это H264, который поддерживается [большинством браузеров](http://caniuse.com/#feat=mpeg4).
* ```-acodec libvo_aacenc``` &mdash; аудио кодек [AAC](http://caniuse.com/#feat=aac).

Список поддерживаемых вашим ffmpeg кодеков можно получить через ```ffmpeg -codecs```.

Вместо ```-vcodec``` встречается запись ```-codec:v``` и ```-c:v```. Если не&nbsp;указать кодеки для конвертации ```ffmpeg -i flashvideo.flv output.mp4```, то&nbsp;ffmpeg [установит дефолтные кодеки для формата файла на выходе](http://stackoverflow.com/a/17793689).

При конвертации задают не&nbsp;только кодеки. Увеличим число настроек:

<pre><code>ffmpeg -i flashvideo.flv <b>-b:v 700k -r 25 -pix_fmt yuv420p</b> -vcodec libx264 \
<b>-b:a 128k -ar 44100</b> -acodec libvo_aacenc <b>-y</b> output.mp4
</code></pre>

Мы&nbsp;установили битрейт для видео ```-b:v``` и&nbsp;аудио ```-b:a``` в&nbsp;700 и&nbsp;128&nbsp;кб/c. Битрейт можно обозначить другими флагами: ```-vb``` и ```-b``` для видео или ```-ab``` для аудио.

Оставшиеся три параметра&nbsp;&mdash; это фреймрейт ```-r 25``` в&nbsp;кадрах в&nbsp;секунду, [цветовая модель YUV](http://www.fourcc.org/yuv.php) равная обычному значению yuv420p и&nbsp;[частота дискретизации звука](http://wikisound.org/Частота_дискретизации) 44100 Гц. Флаг ```-y``` нужен для перезаписи файла, если он&nbsp;уже существует.

## Вырезаем фрагмент видео ##

<pre><code>ffmpeg <b>-ss 10 -t 20</b> -i source_video.mp4 -vcodec copy -acodec copy result.mp4
</code></pre>

Флагом ```-ss``` указываем с&nbsp;какого момента исходного видео обрезаем, ```-t``` &mdash; продолжительность. На&nbsp;выходе мы&nbsp;получим двадцати секундное видео, которое начнется с&nbsp;десятой секунды исходного. Запись ```-ss 00:00:10.250 -t 00:00:20.120``` пригодится для указания более точного промежутка времени. До&nbsp;версии 2.1 FFmpeg в&nbsp;обоих случаях обрезал видео по&nbsp;ближайшему [ключевому кадру](https://en.wikipedia.org/wiki/Key_frame). В&nbsp;новых версиях итоговое видео максимально близко к&nbsp;указанному интервалу.

Мы&nbsp;добавили ```-vcodec copy -acodec copy```, чтобы сохранить кодеки исходного видео. Иначе ffmpeg перекодировал&nbsp;бы их&nbsp;в&nbsp;кодеки по&nbsp;умолчанию. Сейчас видео не&nbsp;перекодируется и&nbsp;команда выполнится быстро. Дальше упростим эту запись флагом ```-c copy```.

Если расположить флаги ```-ss``` и ```-t``` после входящего видео, то&nbsp;итоговое видео будет таким&nbsp;же, но&nbsp;команда будет выполняться дольше. Флаги будут относиться к&nbsp;итоговому видео и FFmpeg будет декодировать фрагмент видео до&nbsp;```-ss```. В&nbsp;первом случае эта часть будет проигнорирована.

Флаг ```-t``` можно заменить на&nbsp;```-to```, указав вместо продолжительности конечную точку. Этот флаг нельзя применить к&nbsp;входящему видео:

<pre><code>ffmpeg -ss 10 -i source_video.mp4 <b>-to 30 -c copy</b> result.mp4
</code></pre>

Команда дала нам другой результат: тридцати секундное видео с&nbsp;десятой секунды исходного. Это&nbsp;произошло, потому&nbsp;что ```-to``` использовал временную шкалу ```result.mp4```, тридцатая секунда на&nbsp;котором равна сороковой секунде ```source_video.mp4 ```. Чтобы использовать исходную шкалу добавим флаг ```-copyts```. Так мы получим такое&nbsp;же видео, как от&nbsp;первой команды:

<pre><code>ffmpeg -ss 10 -i source_video.mp4 -to 30 <b>-copyts</b> -c copy result.mp4
</code></pre>

## Фильтры. Меняем разрешение ##

Один из&nbsp;самых мощных инструментов ffmpeg&nbsp;&mdash; фильтры. Они могут добавлять эффекты, накладывать разные видео друг на&nbsp;друга, сшивать несколько файлов в&nbsp;один. Увидеть список установленных фильтров мы&nbsp;можем по&nbsp;команде ```ffmpeg -filters```. Изменим с&nbsp;их&nbsp;помощью разрешение видео:

<pre><code>ffmpeg -i source_video.avi <b>-vf scale=640:480</b> source_preview.avi
</code></pre>

Мы использовали флаг ```-vf```, указав  фильтр ```scale``` и&nbsp;разрешение ```640:480```. Этот фильтр может
<a href="https://trac.ffmpeg.org/wiki/Scaling%20(resizing)%20with%20ffmpeg">сохранять пропорции и&nbsp;вычислять разрешение динамически</a>.

## Объединение фильтров. Ускоряем воспроизведение ##

<pre><code>ffmpeg -i source_video.mp4 \
<b>-filter_complex "[0:v]setpts=0.5*PTS;[0:a]atempo=2.0"</b> accelerated.mp4
</code></pre>

Мы&nbsp;объединили несколько фильтров в&nbsp;один флагом ```filter_complex``` и&nbsp;получили ускоренный в&nbsp;два раза файл. Чтобы разобраться применим фильтры по&nbsp;одиночке.

<pre><code>ffmpeg -i source_video.mp4 <b>-vf setpts=0.5*PTS</b> accelerated_video.mp4
</code></pre>

Мы&nbsp;ускорили воспроизведение видео дорожки фильтром ```setpts```. Однако аудиодорожка не&nbsp;изменилась, и&nbsp;файл получится той&nbsp;же продолжительности что и&nbsp;был: видео проиграется в&nbsp;2&nbsp;раза быстрее, а&nbsp;последний кадр будет висеть всю вторую половину файла. Если убрать аудио дорожку флагом ```-an```, то длительность итогового файла будет определяться по&nbsp;видео дорожке и&nbsp;будет в&nbsp;два раза меньше исходной.

Наоборот, если нужна только ускоренное аудио без видео, воспользуемся фильтром ```atempo```, а&nbsp;флагом ```vn``` уберем видео дорожку.

<pre><code>ffmpeg -i source_video.mp4 <b>-af atempo=2.0 -vn</b> accelerated_audio.mp3
</code></pre>

Добавив ```filter_complex``` и&nbsp;применив оба фильтра, мы&nbsp;ускорили файл целиком.

[Граф фильтров](http://ffmpeg.org/ffmpeg-filters.html#Filtergraph-description) применяет последовательность из&nbsp;нескольких фильтров к&nbsp;исходному файлу. Мы&nbsp;указали ускорение ```setpts``` для видео дорожки ```[0:v]``` и ```atempo``` для аудио ```[0:a]```. С&nbsp;помощью комбинаций фильтров мы&nbsp;можем решить большинство задач по&nbsp;редактированию видео.

## Склеиваем файлы в один ##

<pre><code>ffmpeg -i input1.mp4 -i input2.mp4  \
-filter_complex  "[0:0] [0:1] [1:0] [1:1] concat=n=2:v=1:a=1 <b>[v] [a]</b>" \
<b>-map "[v]" -map "[a]"</b> -y output.mp4
</code></pre>

Мы&nbsp;видим новый флаг ```map```. Он&nbsp;указывает ffmpeg какие дорожки хотим получить в&nbsp;итоговом файле. Если в&nbsp;наших исходных видео файлах гарантировано одна видео и&nbsp;аудио дорожка, и&nbsp;столько&nbsp;же мы&nbsp;хотим получить на&nbsp;выходе, то&nbsp;флаг map не&nbsp;нужен. Другие примеры использования Map можно посмотреть&nbsp;на [сайте ffmpeg](https://trac.ffmpeg.org/wiki/Map).

Выполним ту же операцию другим методом:

<pre><code>ffmpeg <b>-f concat</b> -i list.txt -c copy output.mp4
</code></pre>

В FFmpeg есть элементы, которые читают или записывают медиа в&nbsp;определенных форматах. Они называются [демультиплексор и&nbsp;мультиплексор](http://ffmpeg.org/ffmpeg-formats.html). ```-f concat```&nbsp;&mdash; это демультиплексор, который принимает текстовый файл, со списком медиа файлов и&nbsp;склеивает их в&nbsp;один. Посмотреть другие элементы можно командой ```ffmpeg -formats```.

Содержимое list.txt:

<pre><code>file 'input1.mp4'
file 'input2.mp4'
</code></pre>

Такой метод удобен, если у&nbsp;нас много файлов и&nbsp;надо склеить их&nbsp;друг за&nbsp;другом. Он не перекодирует видео и работает быстрее первого метода.

Но первый метод применяется чаще. Во-первых, он&nbsp;может принять на&nbsp;вход видео с&nbsp;разными кодеками. Во-вторых, дает большую гибкость. Например, если нужна только часть первого видео, мы&nbsp;можем воспользоваться флагами ```-ss``` и ```-t```. Обратите внимание, эти флаги действуют только на&nbsp;первый файл ```input1.mp4```.

<pre><code>ffmpeg -ss 5 -t 2 -i input1.mp4  -i input2.mp4 \
-filter_complex  "[0:0] [0:1] [1:0] [1:1] concat=n=2:v=1:a=1 [v] [a]" \
-map "[v]" -map "[a]" -y result.mp4
</code></pre>

## Водяной знак ##

Последний пример, который мы&nbsp;рассмотрим&nbsp;&mdash; это наложение водяного знака. Фильтр ```overlay``` принимает на&nbsp;вход координаты расположения водяного знака на&nbsp;итоговом видео.

Расположим водяной знак по&nbsp;центру. Зная размер исходного видео и&nbsp;png картинки, можно вычислить координаты самим. Например при видео 1280&times;720 и&nbsp;водяном знаке 200&times;200, положение по&nbsp;горизонтали ```x = (1280 - 200) / 2 = 540``` и&nbsp;по&nbsp;вертикали ```y = (720 - 200) / 2 = 260```. Соответственно значение фильтра ```"overlay=540:260"```. Однако удобнее написать универсальную команду, чтобы ffmpeg посчитал все за&nbsp;нас. Размер видео получим из&nbsp;параметров ```main_w``` и&nbsp;```main_h```, а&nbsp;водяного знака из&nbsp;```overlay_w``` и&nbsp;```overlay_h```. Далее ту формулу, по которой мы вычисляли координаты запишем в значение фильтра ```"overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2"```. Готово, мы&nbsp;получили команду для наложения водяного знака по центру:

<pre><code>ffmpeg -i source_video.mp4 -i watermark.png \
-filter_complex <b>"overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2"</b> \
-codec:a copy video_protected.mp4
</code></pre>

FFmpeg&nbsp;&mdash; мощный инструмент для работы с&nbsp;видео. Решение других задач с&nbsp;его помощью можно посмотреть в&nbsp;статье [19 команд ffmpeg для всех нужд](http://www.catswhocode.com/blog/19-ffmpeg-commands-for-all-needs).
